package ru.job4j.tutorial.class_loader;

/**
 * Для проверки создаем тестовый класс TestModule.java, который будем
 * загружать нашим загрузчиком
 */

public class TestModule {

    /*
    Каждая итерация нашего цикла в main классе класса Test, оказывается, порождает новую версию класса TestModule,
    не связанную с предыдущими. В этом можно убедиться добавив счетчик.
     */
    //Обрати внимание, перменная static, т.е принадлежит классу.
    private static int counter = 0;

    /*
    В нормальных условиях каждое новое обращение к методу toString() такого класса привело бы к получению строки
    с новым, увеличенным на 1 значением счетчика counter. Если бы в тесте Test.java был обычный вызов
    Class.forName(«TestModule»), мы бы это и увидели: на каждой итерации цикла распечатывались бы разные
    значения счетчика. А с нашим загрузчиком мы все время будем видеть нулевое значение. Каждое пересоздание
    экземпляра загрузчика DynamicClassOverloader приводит к появлению нового пространства имен, в котором
    инициализируется совершенно новая версия класса TestModule, ничего не знающая о предыдущих версиях и о
    содержащихся в них статических переменных.

    Фактически, мы придали языку Java новое свойство – «динамичность» классов. Теперь, обращаясь прямо или косвенно
    к любому классу, придется думать о том, какая именно версия этого класса будет использована и можно ли ее
    использовать совместно с тем классом, который к ней обращается.
    */

    @Override
    public String toString() {
        return "TestModule, version 1! " + (counter++);
    }
}

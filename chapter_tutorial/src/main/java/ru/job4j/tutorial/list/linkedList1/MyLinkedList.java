package ru.job4j.tutorial.list.linkedList1;

import java.util.Arrays;
import java.util.NoSuchElementException;

/**
 * В этом классе реализуем подобие LinkedList.
 * Список есть динамическая структура данных.
 * Связный список, здесь - это набор объектов класса Node, а в LinkedList Java
 * это набор объектов класса Node<E>, с генериками.
 * Это будет односвязный список и не параметризованный,
 * в отличие от LinkedList<>() в Java, который двухсвязный и параметризованный.
 * Наш MyLinkedList будет хранить только целые числа.
 * </>
 * Здесь будут реализованы только некоторые методы.
 */

public class MyLinkedList {

    /*Голова списка. Она нужна чтобы мы могли добавлять элементы.
     * Когда будет создан объект класса MyLinkedList то в переменной Node head будет лежать null.*/
    private Node head;

    /*В этом поле храним размер списка.
     * По умолчанию поле типа примитив int = 0*/
    private int size;

    /*В MyLinkedList создавать конструктор нет смысла, т.к. он пустой и ничего не делает.*/

    /**
     * Метод add().
     * Добавляет элемент в список.
     * При первом добавлении в наш односвязный список
     * нам нужно инициализировать голову head
     */
    public void add(int value) {
        //если это первое добавление в список
        if (head == null) {
            // Создаем новый Node со значением value.
            this.head = new Node(value);
        } else {
            /*Если добавление на первое, а последующее, то:
             * доходим до конца нашего списка и последнему узлу Node
             * в качестве следующего узла нужно указать новый узел с нашим значением.
             *
             * Создаем временный узел temp и укажем его на head,
             * т.е. теперь на головной узел указывают две ссылки,
             * т.к. главную ссылку head мы не можем изменять для итерирования по узлам (!!!)*/
            Node temp = head;
            /* Проходим циклом по всем имеющимся узлам и в конце этого цикла
             * наша ссылка temp будет указывать на последний узел в нашей цепочке.
             * Т.е. выйдя из этого цикла, temp будет указывать на последний элемент нашего
             * односвязного списка.*/
            while (temp.getNext() != null) {
                temp = temp.getNext();
            }
            /*И теперь когда temp указывает на последний элемент в списке, мы
             * можем новый элемент value добавить в конец.*/
            temp.setNext(new Node(value));
        }
        //Увеличиваем нашу переменную size
        size++;
    }

    /**
     * Реализуем метод get().
     */
    public int get(int index) {
        /*Заводим переменную, которая будет указывать на текущий индекс.
         * Проходимся по нашей цепочке и считаем сколько нам отсалось до искомого
         * индекса.*/
        int currentIndex = 0;

        /*Заводим переменную Node temp, которая указывает на голову списка.*/
        Node temp = head;

        while (temp != null) {
            if (currentIndex == index) { //если дошли до нужного индекса, то
                return temp.getValue(); //возвращаем значение текущего узла.
            } else { //если это не так, то
                temp = temp.getNext(); //идем дальше по нашей цепочке. Присваиваем temp следующее значение.
                currentIndex++; //увеличиваем currentIndex
            }
        }
        /*Если пробежались по всему списку и не пришли ни в одну ветку if-else, то
         * это значит, что index больше, чем значение нашего списка. И мы выбросим
         * исключение.*/
        throw new IllegalArgumentException("Выход за пределы размера списка");
    }

    /**
     * Метод удаляющий элементы из нашего односвязного списка
     * по указанному индексу.
     * Метод remove() является сильной стороной LinkedList по сравнению с
     * ArrayList, потому что remove() в связном спске работает очень
     * эффективно. В методе remove() ArrayList приходится сдвигать много элементов при
     * удалении из середины или из начала спсика.
     * <p>
     * Функионал меода remove() похож на функционал метода get(): нам нужно
     * дойти до элемента с нужным индексом, и удалить его (а в get() - получить его).
     * Отличие - нужно дойти не до самого элемента, а до его предшетвенника. Т.к. ссылка
     * указывающая на наш элемент хранится у предшествующего элемента.
     * Пример: [4]->[8]->[12]->null - Чтобы удалить [8], т.е. элемент с индексом 1, нам нужно
     * дойти до [4], т.к. этот узел хранит ссылку на [8]. А находясь в [8] мы будем иметь
     * ссылку уже на [12], т.е. уже на элемент с индексом 2.
     * Далее, доходим до элемента предшествующего искомоу индексу и в его узле меняем
     * ссылку на следующий элемент, т.е. дошли до [4] и заменили у него ссылку с [8] на
     * [12]. Таким образом [8] выпадает (удаляется) из списка!!! И получим новый
     * список [4]->[12]->null
     * <p>
     * Код назначения следующего узла {@Code temp.setNext(temp.getNext ().getNext());},т.е.
     * изменение ссылки на следующий узел на ссылку через узел!!!
     */
    public void remove(int index) {
        /*Заводим переменную Node temp, которая указывает на голову списка.*/
        Node temp = this.head;
        /*Заводим переменную, которая будет указывать на текущий индекс нашего указателя.
         * Проходимся по нашей цепочке и считаем сколько нам отсалось до искомого
         * индекса.
         * На первой итерации наш указатель указывает на головной элемент и с каждой итерацией
         * цикла мы продвигаемся вперед по списку.*/
        int currentIndex = 0;


        /*Если элементов в списке нет, то выбрасываем NoSuchElementException*/
        if (temp == null) {
            throw new NoSuchElementException("Нет элементов в списке.");
        }

        /*Удаление 0-го элемента в связном списке, это отдельный случай.
         * Если индекс = 0, то мы меняем переменную head. Т.е. наше поле head,
         * которое по определению указывает на 1-й элемент в нашем связном
         * списке, мы переопределяем и указываем на следующее поле в нашем списке.
         * Т.е. смещаем его на один узел вперед, тем самым удалив 1-й элемент в списке.
         * И выходим из метода. */
        if (index == 0) {
            head = head.getNext();
            size--; //После удаления элемента нужно обязательно уменьшить размер списка size
            return;
        }


        while (temp != null) {
            /*Если текущий (currentIndex) равен нужному (index - 1), т.е. мы находимся в
             * предшествующем элементе.
             * С каждой итерацией currentIndex увеличивается и когда этот  наш указатель
             * доходит до предшествующего элемента, то мы произволим оперцию удаления.*/
            if ((currentIndex) == index - 1) {
                temp.setNext(temp.getNext().getNext()); //текущему элементу назначаем следующий узел

                /*После удаления элемента нужно обязательно уменьшить размер списка size*/
                size--;

                //И выходим из метода:
                return;

            } else { //если это не так, то
                temp = temp.getNext(); //идем дальше по нашей цепочке. Присваиваем temp следующее значение.
                currentIndex++; //увеличиваем currentIndex
            }
        }

        /*Если пробежались по всему списку и не пришли ни в одну ветку if-else, то
         * это значит, что index больше, чем значение нашего списка. И мы выбросим
         * исключение.*/
        throw new IllegalArgumentException("Выход за пределы размера списка");
    }

    /**
     * Реализуем метод toString().
     * Чтобы в удобном виде просматривать содержимое нашего списка.
     */
    public String toString() { //переопределяем метод из класса Object
        /*Проходимся по всему списку, записываем каждый элемент во временный массив и в конце
         * всё выводим на экран.*/
        int[] result = new int[size];

        int idx = 0;
        Node temp = head; //опять для итерации по всему списку нужна ссылка на голову нашего списка.
        while (temp != null) { //итерируемся пока есть узлы в нашем списке.
            result[idx++] = temp.getValue(); //каждый раз в наш массив добавляем новое значение текущего узла.
            temp = temp.getNext(); //и далее продвигаемся таким образом по нашему списку.
        }
        return Arrays.toString(result); //переведем наш массив в строчное представление.
    }


    /**
     * Влаженный статический класс Node().
     */
    private static class Node {
        private int value; //значение хранящееся в текущем узле
        private Node next; //ссылка на следующий узел

        /**
         * Создадим конструктор, который будет приниматьна на вход значение.
         * Т.к. при создании нового узла мы будем подавать на вход ему значение.
         *
         * @param value значение хранимого элемента в MyLinkedList.
         */
        public Node(int value) {
            this.value = value;
        }

        /*Создадим геттеры и сеттеры для каждого из этих полей.*/
        public int getValue() {
            return value;
        }

        public Node getNext() {
            return next;
        }

        public void setValue(int value) {
            this.value = value;
        }

        public void setNext(Node next) {
            this.next = next;
        }
    }
}
